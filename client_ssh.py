#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse  # https://docs.python.org/3/library/argparse.html
import os
import platform
import re
import sys
from dataclasses import dataclass
from typing import NoReturn, Optional

import paramiko

from logger import logger


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clase
    :return:
    """
    example = "python3 %(prog)s -i 192.168.1.20 -u ubnt -p ubnt -c w"

    my_parser = argparse.ArgumentParser(
        description='%(prog) a is a script to automate the remote execution of commands through ssh',
        usage='{}'.format(example))

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('-i', '--ip', help='IP address.')
    requiered.add_argument('-u', '--user', help='Username')
    requiered.add_argument('-p', '--pwd', help='Password')
    requiered.add_argument('-c', '--cmd', help='command to execute')

    my_parser.add_argument('-port', '--port', action='store_true', help='SSH port', default=22)
    my_parser.add_argument('-s', '--sudo', action='store_true', help='Run with sudo', default=False)
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


@dataclass
class ClientSSH:
    ip: str
    user: str
    password: str
    command: str
    port: int = 22
    sudo: str = 'no'
    debug: bool = False

    def __post_init__(self) -> NoReturn:
        if not self.is_online():
            logger.critical(f'{self.ip} is down!')
            sys.exit(1)

    def is_online(self) -> int:
        """
        Funcion que comprueba si un equipo esta online o no
        return bool: Retorna 0 si el servidor esta online, 1 en caso contrario
        """
        if platform.uname()[0] == 'Windows':
            cmd: str = f'ping -n 1 {self.ip} | find "TTL=" > NUL'
        else:
            cmd: str = f'ping -c 1 {self.ip} | grep ttl > /dev/null'

        response: int = os.system(cmd)
        # and then check the response...
        if self.debug:
            if response == 0:
                print(f'{self.ip} is up!!')
            else:
                print(f'{self.ip} is down :(')
        return response == 0

    def execute_command(self) -> str:
        """
        Funcion para establecer una conexion ssh, son necesarios los 4 primeros
        argumentos, depende de la libreria de cosecha propia TestPing

        :return str, int: retorna un int con el codigo y un string con el resultado
            0 : ejecucion de self.command correcta
            -1: server offline
            -2: fallo autenticacion
            -3: self.command invalido
            -4: Error desconocido
        """

        # sys.path.append('./')
        if self.debug:
            paramiko.util.log_to_file('paramiko.log')

        client: paramiko.client.SSHClient = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            client.connect(self.ip, self.port, self.user, self.password, allow_agent=False, look_for_keys=False)
        except paramiko.AuthenticationException:
            logger.critical(f'Authentication failed: {self.user}/{self.password}')
            sys.exit(-2)
        except Exception as e:
            logger.critical(e)
            sys.exit(-4)

        if self.sudo != 'no':
            stdin, stdout, stderr = client.exec_command('echo %s | sudo -S %s' % (self.password, self.command))
        else:
            stdin, stdout, stderr = client.exec_command(self.command)

        stdout = stdout.read()[:]
        stderr = stderr.read()[:]
        client.close()

        if re.search(r'bash: .*: command not found', str(stderr)):
            logger.critical(f'command invalid: {self.command}')
            sys.exit(-3)
        # hago una copia explicita del valor ya que sino cuando cierro
        # la conexion ssh pierdo el valor
        else:
            return self.format_text(stdout)

    @staticmethod
    def format_text(param_text: bytes) -> Optional[str]:
        if param_text is not None:
            text = param_text.decode('utf-8')
            return str(text)
            # return text.replace('\n', '')
        return param_text


def main():
    args = create_arg_parser()

    ssh: ClientSSH = ClientSSH(args.ip, args.user, args.pwd, args.cmd)
    output = ssh.execute_command()
    print(output)


if __name__ == '__main__':
    main()
