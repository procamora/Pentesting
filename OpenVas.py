#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse  # https://docs.python.org/3/library/argparse.html
import datetime
import re
import sys
from base64 import b64decode
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict, NoReturn

from gvm.connections import TLSConnection
from gvm.protocols.latest import Gmp
from gvm.xml import pretty_print
from lxml import etree

from logger import logger


# config Full and fast               daba56c8-73ec-11df-a475-002264764cea
# config Full and fast ultimate      698f691e-7489-11df-9d8c-002264764cea
# config Full and very deep          708f25c4-7489-11df-8094-002264764cea
# config Full and very deep ultimate 74db13d6-7489-11df-91b9-002264764cea


def create_arg_parser() -> argparse:
    """
    Metodo para establecer los argumentos que necesita la clasek
    :return:
    """
    example = "python3 %(prog)s -s 127.0.0.1"

    my_parser = argparse.ArgumentParser(description='%(prog)s a is a script for managing openvas using the console',
                                        usage='{}'.format(example))

    report_group = my_parser.add_argument_group('report arguments')
    report_group.add_argument('-r', '--report', help='ssss.')
    report_group.add_argument('-id', '--id', help='ssss.')

    scan_group = my_parser.add_argument_group('scan arguments')
    scan_group.add_argument('-s', '--scan', help='ssss.')
    scan_group.add_argument('-t', '--type', default='74db13d6-7489-11df-91b9-002264764cea', help='sssss.')

    my_parser.add_argument('-l', '--list', action='store_true', default=False, help='ssss.')
    my_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose flag (boolean).', default=False)

    # se puede poner en la misma linea
    # my_parser.set_defaults(mmdb=config['DEFAULTS']['BD_GEOIP2'])
    # my_parser.set_defaults(output=config['DEFAULTS']['OUTPUT'])
    # my_parser.print_help()
    if len(sys.argv) == 1:
        my_parser.print_help()
    return my_parser.parse_args()


@dataclass
class IP:
    ip: str
    REGEX: str = r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$'

    def __post_init__(self):
        if not re.search(self.REGEX, self.ip):
            raise AttributeError(f'{self.ip} is not valid address IP')

    def __str__(self) -> str:
        return f'IP(ip=\'{self.ip}\')'


@dataclass
class OpenVas:
    hostname: IP = IP('192.168.1.159')
    user: str = 'admin'
    password: str = 'admin'
    REGEX_ID = r'id=\"(.*)\"'
    file_log: Path = Path('./scans.log')
    export: Dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
        connection = TLSConnection(hostname=self.hostname.ip, timeout=5)
        self.gmp = Gmp(connection)
        try:
            self.gmp.authenticate(self.user, self.password)
        except OSError:
            logger.critical(f"Timeout connect Openvas {self.hostname.ip}")
            sys.exit(1)

        self.export = {
            'PDF': 'c402cc3e-b531-11e1-9163-406186ea4fc5',
            'XML': 'a994b278-1f62-11e1-96ac-406186ea4fc5',
            'LATEX': 'a684c02c-b531-11e1-bdc2-406186ea4fc5',
            'HTML': '6c248850-1f62-11e1-b082-406186ea4fc5'
        }

    def get_version(self):
        # Retrieve current GMP version
        version = self.gmp.get_version()
        # Prints the XML in beautiful form
        pretty_print(version)

    def analize_ip(self, ipaddress: IP, scan_config_id: str):
        """
        Metodo para crear un target, crear una tarea para ese target con un tipo de scanner y ejecutar la tarea
        :type ipaddress: IP
        :param ipaddress:
        :param scan_config_id:
        :return:
        """
        target_id = self._create_target(ipaddress.ip)
        if target_id is None:
            print("create_target failed")
            sys.exit(1)

        # full_and_fast_scan_config_id = 'daba56c8-73ec-11df-a475-002264764cea'
        openvas_scanner_id = '08b69003-5fc2-4037-a479-93b440211c73'

        name_task = f'Python Scan Host {ipaddress.ip}'
        task_id = self._create_task(name_task, target_id, scan_config_id, openvas_scanner_id)

        report_id = self._start_task(task_id)

        string: str = f'Started scan of host {ipaddress.ip} - Corresponding report ID is {report_id}\n'
        print(string)
        with open(str(self.file_log), 'a') as f:
            f.write(string)

    def _create_target(self, ip_address: str) -> Optional[str]:
        """
        Metodo privado para crear un target para una direccion IP proporcionada
        :param ip_address:
        :return:
        """
        # create a unique name by adding the current datetime
        name = f'Python Host {ip_address} {str(datetime.datetime.now())}'
        response = self.gmp.create_target(name=name, hosts=[ip_address])
        return self._get_id(response)

    def _create_task(self, name: str, target_id: str, scan_config_id: str, scanner_id: str) -> Optional[str]:
        """
        Metodo para crear una tarea para un target proporcionado y con una serie de configuraciones
        :param ip_address:
        :param target_id:
        :param scan_config_id:
        :param scanner_id:
        :return:
        """
        response = self.gmp.create_task(name=name, config_id=scan_config_id, target_id=target_id, scanner_id=scanner_id)
        return self._get_id(response)

    def _start_task(self, task_id: str) -> Optional[str]:
        """
        Metodo para iniciar una tarea a traves del id
        :param task_id:
        :return:
        """
        response = self.gmp.start_task(task_id)
        # the response is
        # <start_task_response><report_id>id</report_id></start_task_response>
        print(response)
        regex = r'<report_id>(.*)</report_id>'
        if re.search(regex, response):
            return re.search(regex, response).group(1)
        return None
        # return response[0].text

    def _get_id(self, response: str) -> Optional[str]:
        print(response)
        if re.search(self.REGEX_ID, response):
            return re.search(self.REGEX_ID, response).group(1)
        return None
        # return response.get('id')

    def report(self, report_id, report_type: str) -> NoReturn:
        report_type = report_type.upper()
        if not report_type in self.export.keys():
            logger.critical(f"Format {report_type.lower()} is not compatible, use: PDF, HTML, XML or LATEX")
            sys.exit(1)
        if report_type == 'PDF':
            self.report_aux(report_id, report_type, 'pdf')
        elif report_type == 'XML':
            self.report_aux(report_id, report_type, 'xml')
        elif report_type == 'HTML':
            self.report_aux(report_id, report_type, 'html')
        elif report_type == 'LATEX':
            self.report_aux(report_id, report_type, 'tex')

    def report_aux(self, report_id: str, type: str, extension: str) -> NoReturn:
        response = self.gmp.get_report(report_id=report_id, report_format_id=self.export[type])
        response_xml = etree.fromstring(response)  # conversion de objeto str a xml
        if not self.is_response_valid(response_xml):
            return

        # uso regex porque es mas facil que trabajar con el xml
        # regex que obtiene el reporte en texto plano para convertirlo al formato deseado
        regex = rf'<report_format id=\"(.*)\"><name>{type}</name></report_format>(.*)</report>'
        # re.S es necesario para el formato xml ya que tiene saltos de linea
        content: str = re.search(regex, response, re.IGNORECASE | re.S).group(2)

        pdf_path = Path(f'{report_id}.{extension}').expanduser()

        if type == 'XML':
            # Se guarda como texto en vez de binario
            pdf_path.write_text(content)
            print(f'Done. {type} created: {pdf_path}')
            return

        # convert content to 8-bit ASCII bytes
        binary_base64_encoded_pdf = content.encode('ascii')
        # decode base64
        binary_pdf = b64decode(binary_base64_encoded_pdf)
        # write to file and support ~ in filename path
        pdf_path.write_bytes(binary_pdf)

        print(f'Done. {type} created: {pdf_path}')
        # print(response)

    def is_response_valid(self, response):
        """
        Funcion que comprueba si la respuesta del reporte es correcta
        :param response:
        :return:
        """
        if int(response.get("status")) == 200:
            return True

        logger.critical(response.get("status_text"))
        return False

    def list_tasks(self):
        response = self.gmp.get_tasks()
        response_xml = etree.fromstring(response)

        print("List of reports")
        for task in response_xml.xpath('task'):
            id_report: str = str()
            last_report = task.find("last_report/report")
            if last_report is not None:
                id_report = last_report.get("id")
            else:
                last_report = task.find("current_report/report")
                if last_report is not None:
                    id_report = last_report.get("id")

            name: str = task.find("name").text
            progress: int = int(task.find("progress").text)
            if progress == -1:
                progress = 100
            # si no hay reporte falla al intentar obtener el ultimo
            severity_find = task.find("last_report/report/severity")
            severity: int
            if severity_find is not None:
                severity = severity_find.text
            else:
                severity = -1

            message: str = f'id: {id_report}, name: {name}, progress: {progress}%, severity: {severity}'
            print(message)
            # print(f' -  - )


if __name__ == '__main__':
    args = create_arg_parser()

    openvas: OpenVas = OpenVas()

    if args.scan and args.type:
        ip = IP(args.scan)
        openvas.analize_ip(ip, args.type)
    elif args.report and args.id:
        # report_id = '9331a947-2a02-4979-8933-ddea8bb2bbd7'
        openvas.report(args.id, args.report)
    elif args.list:
        openvas.list_tasks()
    else:
        logger.info("Argument necesary")

        sys.exit(0)

    # pdf_report_format_id = "1a60a67e-97d0-4cbf-bc77-f71b08e7043d"
