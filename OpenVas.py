#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import datetime
import re
import sys
from base64 import b64decode
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict

from gvm.connections import TLSConnection
from gvm.protocols.latest import Gmp
from gvm.xml import pretty_print


# config Full and fast               daba56c8-73ec-11df-a475-002264764cea
# config Full and fast ultimate      698f691e-7489-11df-9d8c-002264764cea
# config Full and very deep          708f25c4-7489-11df-8094-002264764cea
# config Full and very deep ultimate 74db13d6-7489-11df-91b9-002264764cea


# a0704abb-2120-489f-959f-251c9f4ffebd  CPE
# b993b6f5-f9fb-4e6e-9c94-dd46c00e058d  HTML
# 929884c6-c2c4-41e7-befb-2f6aa163b458  ITG
# 9f1ab17b-aaaa-411a-8c57-12df446f5588  LaTeX
# f5c2a364-47d2-4700-b21d-0a7693daddab  NBE
# 1a60a67e-97d0-4cbf-bc77-f71b08e7043d  PDF
# 19f6f1b3-7128-4433-888c-ccc764fe6ed5  TXT
# d5da9f67-8551-4e51-807b-b6a873d70e34  XML

@dataclass
class IP:
    ip: str
    REGEX: str = '^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$'

    def __post_init__(self):
        if not re.search(self.REGEX, self.ip):
            raise AttributeError(f'{self.ip} is not valid address IP')

    def __str__(self) -> str:
        return f'IP(ip=\'{self.ip}\')'


@dataclass
class OpenVas:
    hostname: IP = IP('192.168.1.159')
    user: str = 'admin'
    password: str = 'admin'
    REGEX_ID = 'id=\"(.*)\"'
    file_log: Path = Path('./scans.log')
    export: Dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
        connection = TLSConnection(hostname=self.hostname.ip)
        self.gmp = Gmp(connection)
        self.gmp.authenticate(self.user, self.password)
        self.export = {
            'PDF': 'c402cc3e-b531-11e1-9163-406186ea4fc5',
            'XML': 'd5da9f67-8551-4e51-807b-b6a873d70e34',
            'LATEX': '9f1ab17b-aaaa-411a-8c57-12df446f5588',
            'HTML': 'b993b6f5-f9fb-4e6e-9c94-dd46c00e058d'
        }

    def get_version(self):
        # Retrieve current GMP version
        version = self.gmp.get_version()
        # Prints the XML in beautiful form
        pretty_print(version)

    def analize_ip(self, ipaddress: IP, scan_config_id: str = 'daba56c8-73ec-11df-a475-002264764cea'):
        """
        Metodo para crear un target, crear una tarea para ese target con un tipo de scanner y ejecutar la tarea
        :type ipaddress: IP
        :param ipaddress:
        :param scan_config_id:
        :return:
        """
        target_id = self._create_target(ipaddress.ip)
        if target_id is None:
            print("create_target failed")
            sys.exit(1)

        # full_and_fast_scan_config_id = 'daba56c8-73ec-11df-a475-002264764cea'
        openvas_scanner_id = '08b69003-5fc2-4037-a479-93b440211c73'

        name_task = f'Python Scan Host {ipaddress.ip}'
        task_id = self._create_task(name_task, target_id, scan_config_id, openvas_scanner_id)

        report_id = self._start_task(task_id)

        string: str = f'Started scan of host {ipaddress.ip}. Corresponding report ID is {report_id}'
        print(string)
        with open(str(self.file_log), 'a') as f:
            f.write(string)

    def _create_target(self, ip_address: str) -> Optional[str]:
        """
        Metodo privado para crear un target para una direccion IP proporcionada
        :param ip_address:
        :return:
        """
        # create a unique name by adding the current datetime
        name = f'Python Host {ip_address} {str(datetime.datetime.now())}'
        response = self.gmp.create_target(name=name, hosts=[ip_address])
        return self._get_id(response)

    def _create_task(self, name: str, target_id: str, scan_config_id: str, scanner_id: str) -> Optional[str]:
        """
        Metodo para crear una tarea para un target proporcionado y con una serie de configuraciones
        :param ip_address:
        :param target_id:
        :param scan_config_id:
        :param scanner_id:
        :return:
        """
        response = self.gmp.create_task(name=name, config_id=scan_config_id, target_id=target_id, scanner_id=scanner_id)
        return self._get_id(response)

    def _start_task(self, task_id: str) -> Optional[str]:
        """
        Metodo para iniciar una tarea a traves del id
        :param task_id:
        :return:
        """
        response = self.gmp.start_task(task_id)
        # the response is
        # <start_task_response><report_id>id</report_id></start_task_response>
        print(response)
        regex = '<report_id>(.*)</report_id>'
        if re.search(regex, response):
            return re.search(regex, response).group(1)
        return None
        # return response[0].text

    def _get_id(self, response: str) -> Optional[str]:
        print(response)
        if re.search(self.REGEX_ID, response):
            return re.search(self.REGEX_ID, response).group(1)
        return None
        # return response.get('id')

    def report(self, report_id, report_type: str):
        report_type = report_type.upper()
        if report_type == 'PDF':
            self.report_pdf(report_id)
        elif report_type == 'XML':
            pass
        elif report_type == 'HTML':
            pass
        elif report_type == 'LATEX':
            pass

    def report_pdf(self, report_id):
        response = self.gmp.get_report(report_id=report_id, report_format_id=self.export['PDF'])
        # regex que obtiene el reporte en texto plano para convertirlo al formato deseado
        regex = '<report_format id=\"(.*)\"><name>PDF</name></report_format>(.*)</report>'
        content: str = re.search(regex, response).group(2)

        pdf_filename = Path(f'{report_id}.pdf')
        # convert content to 8-bit ASCII bytes
        binary_base64_encoded_pdf = content.encode('ascii')
        # decode base64
        binary_pdf = b64decode(binary_base64_encoded_pdf)
        # write to file and support ~ in filename path
        pdf_path = Path(pdf_filename).expanduser()
        print(pdf_filename)
        print(pdf_path)
        pdf_path.write_bytes(binary_pdf)

        print('Done. PDF created: ' + str(pdf_path))
        print(response)


if __name__ == '__main__':
    openvas: OpenVas = OpenVas()
    print(openvas)

    ip = IP('127.0.0.1')
    # openvas.analize_ip(ip)

    report_id = '9331a947-2a02-4979-8933-ddea8bb2bbd7'
    openvas.report(report_id, 'pdf')

    # pdf_report_format_id = "1a60a67e-97d0-4cbf-bc77-f71b08e7043d"
